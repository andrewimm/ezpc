# EZPC - 8088 IBM PC Emulator

A high-performance, cycle-accurate emulator of the original IBM PC with Intel 8088 processor, implemented in Rust. The emulator features a three-tier execution system (cold/warm/hot paths) designed for progressive optimization as code executes, aiming to achieve both accuracy and performance through direct dispatch, decode caching, and compiled basic blocks.

## The Real Goal: AI-Generated Code Experiment

While the *original* goal was to build an insanely efficient PC emulator, **the actual goal became to see if Claude Code could write the entire thing, end to end.** Every single line of code in this repository was generated by Claude (Anthropic's AI assistant). I haven't written any code myself—I've architected the design, provided prompts and direction, reviewed the output, and guided the implementation, but **100% of the actual code was AI-generated**.

This project serves as an exploration of what's possible with AI-assisted development in 2025, particularly for complex systems programming tasks like emulator development.

## Current Status

The emulator is in active development with the CPU core implementation underway. Implemented so far:

### CPU Instructions
- **Data Transfer**: MOV, XCHG, LEA, PUSH, POP (registers and segments)
- **Arithmetic**: ADD, ADC, SUB, SBB, INC, DEC, CMP, DAA, DAS
- **Logic**: AND, OR, XOR, TEST, NOT
- **Control Flow**: JMP, CALL, RET (near/far), conditional jumps (Jcc), LOOP family
- **String Operations**: MOVS, STOS, LODS, CMPS, SCAS (byte/word with REP/REPE/REPNE)
- **Flag Manipulation**: CLC, STC, CLI, STI, CLD, STD, PUSHF, POPF, SAHF, LAHF
- **I/O**: IN, OUT (immediate and DX port)
- **Prefixes**: Segment overrides (ES, CS, SS, DS), REP, REPE, REPNE

### Core Features
- Lazy flag evaluation for performance
- ModR/M decoding with all addressing modes
- Segment:offset memory addressing
- REP prefix support with conditional termination
- **GDB remote debugging** over Unix socket
- Comprehensive test suite (320+ tests)

## Architecture

The emulator is designed around three execution tiers:

1. **Tier 1 (Cold Path)**: Direct dispatch using function pointers for first-time instruction execution
2. **Tier 2 (Warm Path)**: Decode cache for frequently executed instructions
3. **Tier 3 (Hot Path)**: Compiled basic blocks for the hottest code paths

Currently, Tier 1 is implemented and functional. See [ARCH.md](ARCH.md) for detailed architecture and implementation plan.

## Building and Testing

```bash
# Build the project
cargo build

# Run tests
cargo test

# Run in release mode (for benchmarking)
cargo build --release
```

## GDB Remote Debugging

The emulator includes built-in support for GDB remote debugging over a Unix socket. This allows you to inspect CPU state, set breakpoints, single-step through code, and examine memory while the emulator runs.

### Basic Usage

1. **Start the emulator with GDB enabled:**

```bash
cargo run --release -- --gdb /tmp/ezpc.sock bios.rom
```

2. **In another terminal, connect with GDB:**

```bash
gdb
(gdb) set architecture i8086
(gdb) target remote /tmp/ezpc.sock
```

### GDB Commands

Once connected, you can use standard GDB commands:

```gdb
# View registers
(gdb) info registers

# Read memory (segmented addressing)
(gdb) x/16xb 0xf000:0xfff0

# Set a breakpoint at a specific address
(gdb) break *0xf000:0xe000

# Single-step instructions
(gdb) stepi

# Continue execution
(gdb) continue

# Read/write registers
(gdb) print $eip
(gdb) set $ax = 0x1234
```

### Supported GDB Features

- ✅ Register read/write (AX, BX, CX, DX, SI, DI, SP, BP, IP, FLAGS, CS, SS, DS, ES)
- ✅ Memory read/write (linear addressing)
- ✅ Breakpoints (software breakpoints at any address)
- ✅ Single-step execution (`stepi`)
- ✅ Continue execution (`continue`)
- ✅ Halt reason reporting (SIGTRAP on break/step)

### Architecture Notes

The GDB integration uses **non-blocking I/O** to avoid impacting emulation performance:
- Socket I/O runs in a separate thread
- Commands are queued and processed each frame
- Emulation never blocks waiting for GDB
- Zero performance overhead when debugger not connected

### Help

```bash
# View all command-line options
cargo run -- --help
```

## Project Structure

- `src/cpu/` - CPU emulation core
  - `state.rs` - CPU registers, flags, and state management
  - `decode/` - Instruction decoding (ModR/M, operands)
  - `execute/` - Instruction handlers by category
  - `tier1/` - Direct dispatch implementation
- `src/debugger/` - GDB remote debugging support
  - `protocol.rs` - GDB Remote Serial Protocol packet handling
  - `socket.rs` - Non-blocking Unix socket I/O thread
  - `commands.rs` - GDB command handlers (g, m, s, c, Z, etc.)
  - `mod.rs` - Debugger core and state management
- `src/components/` - Hardware components (PIC, PIT, keyboard, MDA)
- `src/emulator/` - Emulator state and coordination
- `tests/` - Comprehensive test suite organized by instruction type

## Development Approach

This project follows a strict incremental development methodology:
- Small, atomic commits representing single logical changes
- Test-driven development with tests written alongside implementations
- Continuous verification (cargo check, cargo test, cargo fmt before each commit)
- Architecture-guided implementation following the phases in ARCH.md

Every commit represents a complete, working state of the emulator with all tests passing.

## License

MIT License - See [LICENSE](LICENSE) file for details.

---

**Note**: This is an active experiment in AI-generated code. The human's role has been purely architectural and directorial—the implementation is entirely Claude's work.
