# EZPC - 8088 IBM PC Emulator

A high-performance, cycle-accurate emulator of the original IBM PC with Intel 8088 processor, implemented in Rust. The emulator features a three-tier execution system (cold/warm/hot paths) designed for progressive optimization as code executes, aiming to achieve both accuracy and performance through direct dispatch, decode caching, and compiled basic blocks.

## The Real Goal: AI-Generated Code Experiment

While the *original* goal was to build an insanely efficient PC emulator, **the actual goal became to see if Claude Code could write the entire thing, end to end.** Every single line of code in this repository was generated by Claude (Anthropic's AI assistant). I haven't written any code myself—I've architected the design, provided prompts and direction, reviewed the output, and guided the implementation, but **100% of the actual code was AI-generated**.

This project serves as an exploration of what's possible with AI-assisted development in 2025, particularly for complex systems programming tasks like emulator development.

## Current Status

The emulator is in active development with the CPU core implementation underway. Implemented so far:

### CPU Instructions
- **Data Transfer**: MOV, XCHG, LEA, PUSH, POP (registers and segments)
- **Arithmetic**: ADD, ADC, SUB, SBB, INC, DEC, CMP, DAA, DAS
- **Logic**: AND, OR, XOR, TEST, NOT
- **Control Flow**: JMP, CALL, RET (near/far), conditional jumps (Jcc), LOOP family
- **String Operations**: MOVS, STOS, LODS, CMPS, SCAS (byte/word with REP/REPE/REPNE)
- **Flag Manipulation**: CLC, STC, CLI, STI, CLD, STD, PUSHF, POPF, SAHF, LAHF
- **I/O**: IN, OUT (immediate and DX port)
- **Prefixes**: Segment overrides (ES, CS, SS, DS), REP, REPE, REPNE

### Core Features
- Lazy flag evaluation for performance
- ModR/M decoding with all addressing modes
- Segment:offset memory addressing
- REP prefix support with conditional termination
- Comprehensive test suite (247 tests)

## Architecture

The emulator is designed around three execution tiers:

1. **Tier 1 (Cold Path)**: Direct dispatch using function pointers for first-time instruction execution
2. **Tier 2 (Warm Path)**: Decode cache for frequently executed instructions
3. **Tier 3 (Hot Path)**: Compiled basic blocks for the hottest code paths

Currently, Tier 1 is implemented and functional. See [ARCH.md](ARCH.md) for detailed architecture and implementation plan.

## Building and Testing

```bash
# Build the project
cargo build

# Run tests
cargo test

# Run in release mode (for benchmarking)
cargo build --release
```

## Project Structure

- `src/cpu/` - CPU emulation core
  - `state.rs` - CPU registers, flags, and state management
  - `decode/` - Instruction decoding (ModR/M, operands)
  - `execute/` - Instruction handlers by category
  - `tier1/` - Direct dispatch implementation
- `tests/` - Comprehensive test suite organized by instruction type

## Development Approach

This project follows a strict incremental development methodology:
- Small, atomic commits representing single logical changes
- Test-driven development with tests written alongside implementations
- Continuous verification (cargo check, cargo test, cargo fmt before each commit)
- Architecture-guided implementation following the phases in ARCH.md

Every commit represents a complete, working state of the emulator with all tests passing.

## License

MIT License - See [LICENSE](LICENSE) file for details.

---

**Note**: This is an active experiment in AI-generated code. The human's role has been purely architectural and directorial—the implementation is entirely Claude's work.
